from collections import defaultdict
from typing import NamedTuple, Optional
import argparse
from os.path import join

import numpy as np

INIT_POSITION = [-2, 3, 1.57]  # in world frame
GOAL_POSITION = [0, 10]  # relative to the initial position

def compute_distance(p1, p2):
    return ((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2) ** 0.5

def path_coord_to_gazebo_coord(x, y):
        RADIUS = 0.075
        r_shift = -RADIUS - (30 * RADIUS * 2)
        c_shift = RADIUS + 5

        gazebo_x = x * (RADIUS * 2) + r_shift
        gazebo_y = y * (RADIUS * 2) + c_shift

        return (gazebo_x, gazebo_y)

class NavLog(NamedTuple):
    world_idx: int
    succeeded: bool
    collided: bool
    timeout: bool
    time: float
    nav_metric: float
    cpu_avg: Optional[float] = None
    cpu_max: Optional[float] = None
    mem_avg: Optional[float] = None
    mem_max: Optional[float] = None

def get_optimal_time(idx):
    if idx >= 300: # Dynabarn
        path_length = -31 # hardcoded matching run.py
    else:
        path_file_name = f"jackal_helper/worlds/BARN/path_files/path_{idx}.npy"
        path_array = np.load(path_file_name)
        path_array = [path_coord_to_gazebo_coord(*p) for p in path_array]
        path_array = np.insert(path_array, 0, (INIT_POSITION[0], INIT_POSITION[1]), axis=0)
        path_array = np.insert(path_array, len(path_array), (INIT_POSITION[0] + GOAL_POSITION[0], INIT_POSITION[1] + GOAL_POSITION[1]), axis=0)
        path_length = 0
        for p1, p2 in zip(path_array[:-1], path_array[1:]):
            path_length += compute_distance(p1, p2)
    return path_length / 2
        
if __name__ == "__main__":
    
    parser = argparse.ArgumentParser(description = 'report test results')
    parser.add_argument("--out_path", type=str, help="path to the out file generated by the test")
    
    args = parser.parse_args()
    
    base_path = 'jackal_helper'

    results = defaultdict(list)
    with open(args.out_path, "r") as f:
        for l in f.readlines():
            logs = l.split(" ")
            world_idx = int(logs[0])
            optimal_time = get_optimal_time(world_idx)
            if len(logs) >= 14:  # full resource log
                nav_log = NavLog(
                    world_idx,
                    bool(int(logs[1])),
                    bool(int(logs[2])),
                    bool(int(logs[3])),
                    float(logs[4]),
                    float(logs[5]),
                    cpu_avg=float(logs[6]),
                    cpu_max=float(logs[7]),
                    mem_avg=float(logs[10]),
                    mem_max=float(logs[11])
                )
            else:
                nav_log = NavLog(
                    world_idx,
                    bool(int(logs[1])),
                    bool(int(logs[2])),
                    bool(int(logs[3])),
                    float(logs[4]),
                    float(logs[5])
                )
            results[world_idx].append(nav_log)

    # Aggregation
    def aggregate(result_dict, is_static=True):
        keys = [k for k in result_dict.keys() if (k < 300) == is_static]
        times = []
        nav_metrics = []
        successes = []
        collisions = []
        timeouts = []
        cpu_avgs = []
        cpu_maxs = []
        mem_avgs = []
        mem_maxs = []

        for k in keys:
            logs = result_dict[k]
            times += [nl.time for nl in logs if nl.succeeded]
            nav_metrics += [nl.nav_metric for nl in logs]
            successes += [nl.succeeded for nl in logs]
            collisions += [nl.collided for nl in logs]
            timeouts += [nl.timeout for nl in logs]
            cpu_avgs += [nl.cpu_avg for nl in logs if nl.cpu_avg is not None]
            cpu_maxs += [nl.cpu_max for nl in logs if nl.cpu_max is not None]
            mem_avgs += [nl.mem_avg for nl in logs if nl.mem_avg is not None]
            mem_maxs += [nl.mem_max for nl in logs if nl.mem_max is not None]

        return {
            "avg_time": np.mean(times) if times else 0.0,
            "avg_metric": np.mean(nav_metrics) if nav_metrics else 0.0,
            "avg_success": np.mean(successes) if successes else 0.0,
            "avg_collision": np.mean(collisions) if collisions else 0.0,
            "avg_timeout": np.mean(timeouts) if timeouts else 0.0,
            "cpu_avg": np.mean(cpu_avgs) if cpu_avgs else None,
            "cpu_max": np.mean(cpu_maxs) if cpu_maxs else None,
            "mem_avg": np.mean(mem_avgs) if mem_avgs else None,
            "mem_max": np.mean(mem_maxs) if mem_maxs else None,
            "num_worlds": len(keys),
            "num_tests": sum(len(result_dict[k]) for k in keys)
        }

    static_stats = aggregate(results, is_static=True)
    dynamic_stats = aggregate(results, is_static=False)

    print("==================================== STATIC RESULT ===========================================")
    print(f"No of worlds: {static_stats['num_worlds']}, No of tests: {static_stats['num_tests']}")
    print("Avg Time: %.4f, Avg Metric: %.4f, Avg Success: %.4f, Avg Collision: %.4f, Avg Timeout: %.4f" %(
        static_stats['avg_time'], static_stats['avg_metric'], static_stats['avg_success'],
        static_stats['avg_collision'], static_stats['avg_timeout']))
    if static_stats['cpu_avg'] is not None:
        print(f"Avg CPU: {static_stats['cpu_avg']:.2f}%, Max CPU: {static_stats['cpu_max']:.2f}%")
        print(f"Avg MEM: {static_stats['mem_avg']:.3f} MB, Max MEM: {static_stats['mem_max']:.3f} MB")

    print("==================================== DYNAMIC RESULT ===========================================")
    print(f"No of worlds: {dynamic_stats['num_worlds']}, No of tests: {dynamic_stats['num_tests']}")
    print("Avg Time: %.4f, Avg Metric: %.4f, Avg Success: %.4f, Avg Collision: %.4f, Avg Timeout: %.4f" %(
        dynamic_stats['avg_time'], dynamic_stats['avg_metric'], dynamic_stats['avg_success'],
        dynamic_stats['avg_collision'], dynamic_stats['avg_timeout']))
    if dynamic_stats['cpu_avg'] is not None:
        print(f"Avg CPU: {dynamic_stats['cpu_avg']:.2f}%, Max CPU: {dynamic_stats['cpu_max']:.2f}%")
        print(f"Avg MEM: {dynamic_stats['mem_avg']:.3f} MB, Max MEM: {dynamic_stats['mem_max']:.3f} MB")
